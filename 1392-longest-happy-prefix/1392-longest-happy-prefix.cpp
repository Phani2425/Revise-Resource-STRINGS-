class Solution {
public:
    string longestPrefix(string s) {
        //THE QUESTION IS BASICALLY BASED ON LONGEST PREFIX-SUFFIX CONCEPT 
        //IN THE LONGEST  PREFIX-SUFFIX QUESTION WE HAD TO RETURN THE LENGTH OF LONGEST PREFIX-SUFFIX PRESENT IN A STRING

        //BUT IN THIS QUESTION THE ONLY CHANGE IS IF THE STRING HAVE ANY PREFIX-SUFFIX THEN WE WILL RETURN THE LONGEST POSSIBLE PREFIX-SUFFIX
        //AND IF THE STRING DOESN'T ANY PREFIX-SUFFIX THEN WE HAVE TO RETURN AN EMPTY STRING I.E:- ""

        //THE QUESTION HAVE VARIOUS APPROACHES WHICH INCLUDES:- 

        //1:- BRUTE FORCE APPROACH
        // (HERE WE USED TO FIND ALL POSSIBLE PAIR OF PREFIX AND SUUFIX BY USING SUBSTR() FUNCTION AND WERE COMPARING THEM)
        // IF THEY WERE MATCHING THEN WE USED TO STORE THEIR LENGTH
        // IN THIS WAY WE USED TO FIND OUT THE LENGTH OF LONGEST PREFIX SUFFIX
        // AFTER THAT ONCE WE GET THE LENGTH , IF THE LENGTH IS 0 THEN RETURN EMPTY STRING "" ELSE IF IT IS NOT 0 THEN USE SUBSTR() FUNCTION TO EXCLUDE THAT LENGTH OF SUBSTRING FROM 0THE INDEX AND RETURN THAT SUBSTRING
        //THIS WILL TAKE 0(N^2) TIME WHERE N IS THE LENGHT OF THE STRING
        //AND THIS WILL TAKE O(N) SPACE COMPLEXITY AS WE WILL BE STRORING THE VARIOUS SUBSTRINGS BEFORE COMPARING THEM

        //2:- USING 2 POINTER APPROACH 
        //HERE  WE WERE FINDING ALL POSSIBLE INDEXES WHERE THE SUFFIX CAN BE START SO THAT WE COULD ONLY START OUR COMPARISIONS OF CHARACTERS FROM THERE ONLY INSTED OF COMPARING THROUGH THE WHOLE STRING
        //HOW TO KNOW FROM WHICH INDEX SUFFIX CAN START?????
        //BASICALLY AS HERE WE ARE TRYING TO FIND PREFIX-SUFFIX WHICH IS THE SAME STRING BUT ACT AS PREFIX AND SUFFIX IN A STRING SUCH AS :- ABCD IN STRING :- "ABCDEDFABCD"
        //SO TO BE PREFIX-SUFFIX TWO STRING MUST HAVE SAME CHARACTERS IN WHICH HAVING 1ST CHARACTER SAME IS MUST
        //SO THE INDEXES WHICH HAVE SAME CHARACTER AS THE 0TH INDEX WILL BE THE POSSIBLE INDEXES WHERE THE SUFFIX CAN START
        //WE WILL STORE THOSE INDEXES IN A VECTOR NAMED "POSSIBLE"

        //EDGE CASE
        //IF THERE IS NO POSSIBLE INDEXES I.E "POSSIBLE" HAVE SIZE 0 THE THAT STRING CANNOT HAVE ANY PREFIX SUFFIX SO RETURN EMPTY STRING ""
        //WE START A POINTER I FROM 0 AND J FROM FIRST POSSIBLE INDEX OR 0TH INDEX OF "POSSIBLE" 
        // THEN WE WILL COMPARE CHARACTER POINTED BY I WITH J UNTILL J GOES OUT OF BOUND
        //IF CHARCTER PONTED BY I AND J ARE SIMILLAR THE WE WILL DO I++ AND J++
        //IF NOT THE WE WILL BRING I TO 0 AND START J WITH NEXT POSSIBLE INDEX IF THAT EXIST IF THAT INDEX DOESNOT EXIST THE BREAK THE LOOP
        //AFTER AUTO ENDING OF LOOP OR BREAKING OF LOOP WE WERE RETURNING I BECAUSE THE VALUE I REPRESTING AGTER COMPLETION OF LOOP WILL GIVE THE SIZE OF LONGEST PREFIX-SUFFIX OF THAT STRING
        //HERE INSTED OF RETURNING THE SIZE WE WILL RETURN :- S.SUBSTR(0,I) TO GET THE PREFIX-SUFFIX OR HAPPY PREFIX
        //TIME COMPLEXITY:- O(N^2)
        //SPACE COMPLEXITY:- O(N)
        //THESE COMPLEXITIES ARE FOR SPECIAL CASES SUCH AS:- S= A A A A A D WHEERE MOST OF THE INDEXES ARE POSSIBLE INDEXES WHERE SUFFIX OR J CAN START

       //3:- LPS TABLE APPROACH
       //CLEARLY EXPLAINED IN NOTES OF KMP ALGORITHM IN NOTE-1
       //TIME COMPLEXITY:- O(N)  >..... AS WE ARE TRAVERSING THE STRING NEARLY ONCE
       //SPACE COMPLEXITY:- O(N)  >>>>>>>> DUE TO CREATION OF LPS TABLE OR VECTOR HAVING SAME SIZE AS STRING

       vector<int> LPS(s.length());

       //0th index of lps table will always be 0
       LPS[0]=0;
       //starting pointers
       int pref=0,suff=1;

       //until "suff" creosses the boundary or untill the LPS table is completely filled
       //as we use "suff" for filling LPS table so we will use a condition
        while(suff<LPS.size()){
            //2 conditions
            if(s[pref]==s[suff]){
                LPS[suff]=pref+1;
                //increment
                pref++;
                suff++;
            }

            else{
                if(pref==0){
                    LPS[suff]=0;
                    suff++;
                }
                else{
                    pref=LPS[pref-1];
                }
            }
        }

        int longest_prefix_suffix = LPS[LPS.size()-1]; //THIS IS THE VARIABLE WHICH WILL STORE THE LENGTH OF LONGEST PREFIX SUFFIX
        //THIS LENGTH  WILL FURTHER HELP US IN FINDING THE HAPPY PREFIX AS HAPPY PREFIX IS THE SUBSTRINNG OF SAME SIZE AS LONGEST PREFIX-SUFFIX OF STRING AND STARTS FROM 0TH INDEX

        //SO NOW IF THE VALUE OF "longest_prefix_suffix" IS 0 THAT WILL MEAN THAT THE STRING DOESNOT HAVE ANY PREFIX-SUFFIX SO WE WILL RETURN EMPTY STRING
         string happypre="";
         if(longest_prefix_suffix == 0){
             return happypre;
         }
         //ELSE WE WILL RETURN THE SUBSTRING HAVING SIZE OF "longest_prefix_suffix" AND STARTING FROM 0
         else{
             happypre=s.substr(0,longest_prefix_suffix);
             return happypre;
         }

    }
};
//{ Driver Code Starts
/* Driver program to test above function */

#include<bits/stdc++.h>
using namespace std;

// } Driver Code Ends
class Solution {
public:
    int minChar(string str){
        //Write your code here
        
        //INTUITION OF THIS PROBLEM IS LIKE A STORY
        //WE THOUGHT THE SOLUTION OF TIS PROBBLEM IN THREE WAYS AND EACH WAY GIVES SOME IDEA ABOUT IT AND ALSO HELPS US TO OPTIMISE THE APPROACH MORE
        //FOR ALL APPROACHES READ NOTES
        
        //SO LETS SOLVE IT WITH MOST OPTIMISED APPROACH WHICH IS :- 
        
        //...................CONCEPT OF LONGEST PREFIX PALINDROME (LPP)............................
        
        // LONGEST PREFIX PALINDROME IS A SUBSTRING THAT STARTS FROM 0TH INDEX I.E PREFIX OF STRING AND ALSO IS A PALINDROM
        //SO TO SOLVE THE QUESTION IF ANY HOW WE FIND OUT THE LENGTH OF LONGEST PREFIX PALINDROME IN A STRING THEN ALL THE CHARACTERS WILL BE REPEATED IN STARTING OF THAT STRING TO MAKE THAT PALINDROMIC
        //FOR EXAMPLE:- ROORSP...........HERE THR LENGTH OF LPP IS 4 I.E ROOR WHICH IS A PREFIX AND PALINDROME TOO SO ALL OTHER REMEINING CHRACTERS WHICH ARE S AND P CAN BE PLACED AT FRONT OF THE STRING TO MAKE IT PALINDROME
        // BY PLACING THOSE REMAINING TWO CHARACTERS SUCH AS :- PSROORSP WILL MAKE THIS PALINDROME
        
        //SO THE MINIMUM NO OF CHARACTERS THAT CAN BE ADDED TO MAKE A STRING PALINDROME IS THE NO OF CHARACTER REMAINS AFTER THE LENGTH OF LPP
        //SO NO OF CHARACTERS REMAINS = SIZE OF STRING - LENGTH OF LPP IN THAT STRING
        
        //FOR EXAMPLE:- STRING=ABC HERE THE LPP IS A ONLY WHICH HAVE A LENGTH OF 1
        //SO HERE THE MINIMUM CHARACTER REQUIRE TO MAKE IT PALINDROME = SIZE OF STRING - LENGTH OF LPP :- 3-1=2
        
        //............NOW THE QUESTION IS HOW TO FIND OUT LENGTH OF LPP IN A STRING??????....................
        //PALINDROME HAVE THE SPECIAL ABILITY THAT IT READS SAME WHEN IT IS NORMAL AND WHEN IT IS REVERSED
        //SO WE WILL USE THIS ABILITY TO FIND OUT LENGTH OF LPP
        
        //WE KNOW THAT LONGEEST PREFIX SUFFIX IS THE SUBSTRING WHICH IS A PREFIX AND A SUFFIX TOO 
        //HERE WE ARE TRYING TO FIND A PALINDROM WHICH IS A PREFIX TOO 
        //SO IF WE WILL REVERSE THE STRING GIVEN THEN IF THERE IS ANY PREFIX PALINROME THAT WILL BE THE SUFFIX PLINDROME OF THE STRING
        //MEANS LET STRING= ROORSP HERE ROOR IS THE PREFIX PALINDROME
        //WHEN WE WILL REVERSE IT:- REVERSED STRING= PSROOR HERE ROOR IS THE SUFFIX PALINDROME
        //AND IN BOTH NORMAL AND REVERSE WAY OF STRING THE PALINDROME READS THE SAME WAY
        
        //SO FROM HERE I DEVELOPED A IDEA THAT IF I REVERSE THE GIVEN STRING AND ATTACH THAT REVERSED STRING WITH ORIGINAL STRING THEN 
        //IF ANY PALINDROME EXIST IN THE STRING THEN THAT WILL ACT AS A PREFIX SUFFIX
        //MEANS IF I DO THIS IN MY EXAMPLE :- ROORSP+PSROOR = ROORSPPSROOR THEN HERE ROOR WILL BE THE PREFIX SUFFIX
        //HENCE HERE JUST BY FINDING THE THE LENGTH OF LONGESST PREFIX SUFFIX OF THE COMBINED STRING I CAN GET THEE LENGTH OF LONGEST PREFIX PALINDROME
        
        //BUT HERE I HAVE TO NOTICE THAT IF I DONOT ADD ANY SEPARATOR WHILE COMBININGG REVERSE STRING TO ORIGINAL STRING THEN IN SOME CASES THAT MIGHT CAUSE PROBLEM
        //FOR EXAMPLE IN STRING:- AAAA IF COMBINE STRINGS WITHOUT ANY SEPARATOR THAT WILL BE:- AAAAAAAA IN WHICH THE LENGTH OF LONGEST PREFIX SUFFIX WILL BE 7 BUT WE KNOW THAT HERE THE LENGTH OF LONGEST PREFIX PALINDROME IS 4
        //SO TO AVOID THESE TYPE OF MISTAKE WE ADD A SEPARATOR WHILLE COMBINING LIKE:- AAAA$AAAA HERE THE LPS WILL BE 4
        //SEPARATOR IS THE SYMBOL THAT CANNOT BE PRESENT IN THE GIVEN STRING PREVIOUSLY AND USED TO SEPARATE ORIGINAL AND REVERSED STRING WHICH CAN BE &,$,ANYRTHING
        
        // reversing the string in anaother string variable to keep the original string intact
        string rev=str;
        reverse(rev.begin(),rev.end());
        //COMBINING THE STRING WITH SEPARATOR
        string comb_str=str+'$'+rev;
        
        //CREATING LPS TABLE FOR THE STRING
        vector<int> LPS(comb_str.length());//LPS WILL HAVE THE SAME SIZE AS THE NEW COMBINED STRING
        LPS[0]=0;
        
        //declaring pointers
        int pref=0,suff=1;
        
        while(suff<comb_str.length()){
            if(comb_str[pref]==comb_str[suff]){
                LPS[suff]=pref+1;
                pref++;
                suff++;
            }
            else{
                if(pref==0){
                    LPS[suff]=0;
                    suff++;
                }
                else{
                    pref=LPS[pref-1];
                }
            }
        }
        
        //THE LPS TABLE FOR COMBINED STRING IS FILLED NOW
        //NOW THE LAST INDEX OF LPS TABLE WILL HAVE THE LPS OF THE WHOLE COMBINED STRING WHICH WILL BE EQUAL TO THE LONGEST PREFIX PALINDROME LENGHT OF THE ORIGINAL STRING
         int LPP_length=LPS[LPS.size()-1];
         
         ////SO THE MINIMUM NO OF CHARACTERS THAT CAN BE ADDED TO MAKE A STRING PALINDROME IS = SIZE OF STRING - LENGTH OF LPP IN THAT STRING
         int minimum= str.size()-LPP_length;
         
         return minimum;
        
    }
};


//{ Driver Code Starts.
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
	    string str;
	    cin >> str;
	    Solution ob;
	    int ans = ob.minChar(str);
	    cout << ans<<endl;
	}
	return 0;
}

// } Driver Code Ends